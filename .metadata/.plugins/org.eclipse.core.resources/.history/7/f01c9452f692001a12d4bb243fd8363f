
//	MIT License
//
//	Copyright (c) 2017 Matej Artnak
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.
//
//
//
//-----------------------------------
//	ILI9341 Driver library for STM32
//-----------------------------------
//
//	While there are other libraries for ILI9341 they mostly require either interrupts, DMA or both for fast drawing
//	The intent of this library is to offer a simple yet still reasonably fast alternatives for those that
//	do not wish to use interrupts or DMA in their projects.
//
//	Library is written for STM32 HAL library and supports STM32CUBEMX. To use the library with Cube software
//	you need to tick the box that generates peripheral initialization code in their own respective .c and .h file
//
//
//-----------------------------------
//	Performance
//-----------------------------------
//	Settings:	
//	--SPI @ 50MHz 
//	--STM32F746ZG Nucleo board
//	--Redraw entire screen
//
//	++		Theoretical maximum FPS with 50Mhz SPI calculated to be 40.69 FPS
//	++		320*240 = 76800 pixels, each pixel contains 16bit colour information (2x8)
//	++		Theoretical Max FPS: 1/((320*240*16)/50000000)
//
//	With ART Accelerator, instruction prefetch, CPI ICACHE and CPU DCACHE enabled:
//
//	-FPS:									39.62
//	-SPI utilization:			97.37%
//	-MB/Second:						6.09
//
//	With ART Accelerator, instruction prefetch, CPI ICACHE and CPU DCACHE disabled:
//
//	-FPS:									35.45
//	-SPI utilization:			87.12%
//	-MB/Second:						5.44
//	
//	ART Accelerator, instruction prefetch, CPI ICACHE and CPU DCACHE settings found in MXCUBE under "System-> CORTEX M7 button"
//
//
//
//-----------------------------------
//	How to use this library
//-----------------------------------
//
//	-generate SPI peripheral and 3 GPIO_SPEED_FREQ_VERY_HIGH GPIO outputs
//	 		++Library reinitializes GPIOs and SPIs generated by gpio.c/.h and spi.c/.h using MX_X_Init(); calls
//			++reinitialization will not clash with previous initialization so generated initializations can be laft as they are
//	-If using MCUs other than STM32F7 you will have to change the #include "stm32g4xx_hal.h" in the ILI9341_STM32_Driver.h to your respective .h file
//	-define your HSPI_INSTANCE in ILI9341_STM32_Driver.h
//	-define your CS, DC and RST outputs in ILI9341_STM32_Driver.h
//	-check if ILI9341_SCREEN_HEIGHT and ILI9341_SCREEN_WIDTH match your LCD size
//			++Library was written and tested for 320x240 screen size. Other sizes might have issues**
//	-in your main program initialize LCD with ILI9341_Init();
//	-library is now ready to be used. Driver library has only basic functions, for more advanced functions see ILI9341_GFX library	
//
//-----------------------------------

/* Includes ------------------------------------------------------------------*/
#include "ILI9341_STM32_Driver.h"
#include "spi.h"
#include "gpio.h"

/* Global Variables ------------------------------------------------------------------*/
volatile uint16_t LCD_HEIGHT = ILI9341_SCREEN_HEIGHT;
volatile uint16_t LCD_WIDTH	 = ILI9341_SCREEN_WIDTH;

// private function prototypes
void _LCD_Enable();
void _LCD_Reset();
void _SPI_SendByte(unsigned char data_buffer, uint8_t pre_frame_delay, uint8_t post_frame_delay);
void _SPI_SendByteMultiByte(unsigned char *data_buffer, uint32_t buffer_size, uint8_t pre_frame_delay, uint8_t post_frame_delay);
void _SPI_SendCommand(uint8_t command);
void _SPI_SendData(uint8_t data);

uint16_t BURST_MAX_SIZE = 500;

#define SPI_DELAY_HOLD 3
//#define USE_HAL_SPI
#define USE_BARE_SPI

/*
 *
 * 	Initialise SPI peripheral
 *
 */
void ILI9341_SPI_Init(void)
{

   	// check SPI enabled
	if ((SPI_PERIPH->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
	{
		SPI_PERIPH->CR1 |= SPI_CR1_SPE;
	}

	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);
}

/*
 *
 * 	Send single byte over SPI using HAL or (optimised) direct-to-register
 *
 */
void _SPI_SendByte(unsigned char data_buffer, uint8_t pre_frame_delay, uint8_t post_frame_delay)
{

#ifdef USE_HAL_SPI
	HAL_SPI_Transmit(HSPI_INSTANCE, &SPI_Data, 1, 1);
#endif

#ifdef USE_BARE_SPI

    // pre frame delay
   	for(int d = 0; d < pre_frame_delay ; d++)
   		asm("nop");

	// check transmit buffer empty
	if((SPI_PERIPH->SR & SPI_SR_TXE) == SPI_SR_TXE)
	{
		*(volatile uint8_t *)&SPI_PERIPH->DR = data_buffer;
	}

    // post frame delay
   	for(int d = 0; d < post_frame_delay ; d++)
   		asm("nop");

#endif

}

/*
 *
 * 	Send multiple bytes over SPI using HAL or (optimised) direct-to-register
 *
 */
void _SPI_SendByteMultiByte(unsigned char *data_buffer, uint32_t buffer_size, uint8_t pre_frame_delay, uint8_t post_frame_delay)
{

#ifdef USE_HAL_SPI
	HAL_SPI_Transmit(HSPI_INSTANCE, (unsigned char *)data_buffer, buffer_size, 2 );
#endif

#ifdef USE_BARE_SPI

    // pre frame delay
   	for(int d = 0; d < pre_frame_delay ; d++)
   		asm("nop");

	uint8_t *p_data_buffer = (uint8_t *)data_buffer;
	//volatile uint16_t TxXferCount = (uint16_t)buffer_size;

	while (buffer_size > 0U)
	{
		// check transmit buffer empty
		if ((SPI_PERIPH->SR & SPI_SR_TXE) == SPI_SR_TXE)
		{
			if (buffer_size > 1U)
			{
				// write on the data register in packing mode
				SPI_PERIPH->DR = *((uint16_t *)p_data_buffer);
				p_data_buffer += sizeof(uint16_t);
				buffer_size -= 2U;
			}
			else
			{
				*((volatile uint8_t *)&SPI_PERIPH->DR) = (*p_data_buffer);
				p_data_buffer++;
				buffer_size--;
			}
		}
	}

	// clear SPI overrun flag
	SPI_PERIPH->SR &= ~(SPI_SR_OVR);

    // post frame delay
   	for(int d = 0; d < post_frame_delay ; d++)
   		asm("nop");

#endif

}

/*
 *
 * 	Send command to LCD
 *
 */
void _SPI_SendCommand(uint8_t command)
{
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);
	LCD_DC_PORT->ODR &= ~(LCD_DC_PIN);

	_SPI_SendByte(command, 0 , 0);

	// Additional SPI CS "low" hold
	for(int x=0; x < SPI_DELAY_HOLD; x++)
		LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	LCD_CS_PORT->ODR |= LCD_CS_PIN;
}

/*
 *
 * 	Send Data to LCD
 *
 */
void _SPI_SendData(uint8_t data)
{
	LCD_DC_PORT->ODR |= LCD_DC_PIN;
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	_SPI_SendByte(data, 0 , 0);

	// Additional SPI CS "low" hold
	for(int x=0; x < SPI_DELAY_HOLD; x++)
		LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);
}

/*
 *
 * 	Set defined area of frame memory for MCU write access
 *
 *	Top left of area (sc, sp):
 *	sc	-	"start column"
 *	sp	- 	"start page"
 *
 *	bottom right of area (ec, ep):
 *	ec 	- 	"end column"
 *	ep	- 	"end page"
 */
void ILI9341_Set_Address(uint16_t sc, uint16_t sp, uint16_t ec, uint16_t ep)
{
	// send "Column Address Set" command
	_SPI_SendCommand(0x2A);
	_SPI_SendData(sc >> 8);
	_SPI_SendData(sc);
	_SPI_SendData(ec >> 8);
	_SPI_SendData(ec);

	// send "Page Address Set" command
	_SPI_SendCommand(0x2B);
	_SPI_SendData(sp >> 8);
	_SPI_SendData(sp);
	_SPI_SendData(ep >> 8);
	_SPI_SendData(ep);

	_SPI_SendCommand(0x2C);
}


/*
 *
 * 	Reset LCD
 *
 */
void _LCD_Reset()
{
	LCD_RST_PORT->ODR &= ~(LCD_RST_PIN);
	HAL_Delay(200);
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);
	HAL_Delay(200);
	LCD_RST_PORT->ODR |= LCD_RST_PIN;
}

/*
 *
 * 	Set LCD orientation
 *
 */
void ILI9341_Set_Rotation(uint8_t rotation)
{
	
	uint8_t screen_rotation = rotation;
	
	_SPI_SendCommand(0x36);
	//HAL_Delay(1);

	switch(screen_rotation)
	{
		case SCREEN_VERTICAL_1:
			_SPI_SendData(0x40|0x08);
			LCD_WIDTH = 240;
			LCD_HEIGHT = 320;
			break;
		case SCREEN_HORIZONTAL_1:
			_SPI_SendData(0x20|0x08);
			LCD_WIDTH  = 320;
			LCD_HEIGHT = 240;
			break;
		case SCREEN_VERTICAL_2:
			_SPI_SendData(0x80|0x08);
			LCD_WIDTH  = 240;
			LCD_HEIGHT = 320;
			break;
		case SCREEN_HORIZONTAL_2:
			_SPI_SendData(0x40|0x80|0x20|0x08);
			LCD_WIDTH  = 320;
			LCD_HEIGHT = 240;
			break;
		default:
			//EXIT IF SCREEN ROTATION NOT VALID!
			break;
	}
}

/*
 *
 * Enable LCD display
 *
 */
void _LCD_Enable()
{
	LCD_RST_PORT->ODR |= LCD_RST_PIN;
}

/*
 *
 * Initialize LCD display
 *
 */
void ILI9341_Init(void)
{

	_LCD_Enable();
	ILI9341_SPI_Init();
	_LCD_Reset();

	//SOFTWARE RESET
	_SPI_SendCommand(0x01);
	HAL_Delay(2000);

	//POWER CONTROL A
	_SPI_SendCommand(0xCB);
	_SPI_SendData(0x39);
	_SPI_SendData(0x2C);
	_SPI_SendData(0x00);
	_SPI_SendData(0x34);
	_SPI_SendData(0x02);

	//POWER CONTROL B
	_SPI_SendCommand(0xCF);
	_SPI_SendData(0x00);
	_SPI_SendData(0xC1);
	_SPI_SendData(0x30);

	//DRIVER TIMING CONTROL A
	_SPI_SendCommand(0xE8);
	_SPI_SendData(0x85);
	_SPI_SendData(0x00);
	_SPI_SendData(0x78);

	//DRIVER TIMING CONTROL B
	_SPI_SendCommand(0xEA);
	_SPI_SendData(0x00);
	_SPI_SendData(0x00);

	//POWER ON SEQUENCE CONTROL
	_SPI_SendCommand(0xED);
	_SPI_SendData(0x64);
	_SPI_SendData(0x03);
	_SPI_SendData(0x12);
	_SPI_SendData(0x81);

	//PUMP RATIO CONTROL
	_SPI_SendCommand(0xF7);
	_SPI_SendData(0x20);

	//POWER CONTROL,VRH[5:0]
	_SPI_SendCommand(0xC0);
	_SPI_SendData(0x23);

	//POWER CONTROL,SAP[2:0];BT[3:0]
	_SPI_SendCommand(0xC1);
	_SPI_SendData(0x10);

	//VCM CONTROL
	_SPI_SendCommand(0xC5);
	_SPI_SendData(0x3E);
	_SPI_SendData(0x28);

	//VCM CONTROL 2
	_SPI_SendCommand(0xC7);
	_SPI_SendData(0x86);

	//MEMORY ACCESS CONTROL
	_SPI_SendCommand(0x36);
	_SPI_SendData(0x48);


	//PIXEL FORMAT
	_SPI_SendCommand(0x3A);
	_SPI_SendData(0x55);

	//FRAME RATIO CONTROL, STANDARD RGB COLOR
	_SPI_SendCommand(0xB1);
	_SPI_SendData(0x00);
	_SPI_SendData(0x18);

	//DISPLAY FUNCTION CONTROL
	_SPI_SendCommand(0xB6);
	_SPI_SendData(0x08);
	_SPI_SendData(0x82);
	_SPI_SendData(0x27);


	//3GAMMA FUNCTION DISABLE
	_SPI_SendCommand(0xF2);
	_SPI_SendData(0x00);

	//GAMMA CURVE SELECTED
	_SPI_SendCommand(0x26);
	_SPI_SendData(0x01);

	//POSITIVE GAMMA CORRECTION
	_SPI_SendCommand(0xE0);
	_SPI_SendData(0x0F);
	_SPI_SendData(0x31);
	_SPI_SendData(0x2B);
	_SPI_SendData(0x0C);
	_SPI_SendData(0x0E);
	_SPI_SendData(0x08);
	_SPI_SendData(0x4E);
	_SPI_SendData(0xF1);
	_SPI_SendData(0x37);
	_SPI_SendData(0x07);
	_SPI_SendData(0x10);
	_SPI_SendData(0x03);
	_SPI_SendData(0x0E);
	_SPI_SendData(0x09);
	_SPI_SendData(0x00);

	//NEGATIVE GAMMA CORRECTION
	_SPI_SendCommand(0xE1);
	_SPI_SendData(0x00);
	_SPI_SendData(0x0E);
	_SPI_SendData(0x14);
	_SPI_SendData(0x03);
	_SPI_SendData(0x11);
	_SPI_SendData(0x07);
	_SPI_SendData(0x31);
	_SPI_SendData(0xC1);
	_SPI_SendData(0x48);
	_SPI_SendData(0x08);
	_SPI_SendData(0x0F);
	_SPI_SendData(0x0C);
	_SPI_SendData(0x31);
	_SPI_SendData(0x36);
	_SPI_SendData(0x0F);

	//EXIT SLEEP
	_SPI_SendCommand(0x11);
	HAL_Delay(240);

	//TURN ON DISPLAY
	_SPI_SendCommand(0x29);
	
	//STARTING ROTATION
	ILI9341_Set_Rotation(SCREEN_VERTICAL_1);
}


/*
 *
 * 	Sends block colour information to LCD
 *
 *	entire data sent to this function is a CHUNK < BURST_MAX_SIZE
 *	each CHUNK is broken down into smaller BLOCKS
 */
void _LCD_Draw_colour_Burst(uint16_t chunk_xpos, uint16_t chunk_ypos, uint16_t colour, uint32_t chunk_size, CHUNK_Type chunk_type)
{

	uint32_t buffer_size = 0;
	if((chunk_size*2) < BURST_MAX_SIZE)
	{
		buffer_size = chunk_size;
	}
	else
	{
		buffer_size = BURST_MAX_SIZE;
	}

	unsigned char chifted = 	colour>>8;;
	unsigned char burst_buffer[buffer_size];
	for(uint32_t j = 0; j < buffer_size; j+=2)
	{
			burst_buffer[j] = 	chifted;
			burst_buffer[j+1] = colour;
	}
	
	uint32_t Sending_size = chunk_size*2;

	// make sure we don't divide by size=0
	uint32_t Sending_in_Block = 1;
	uint32_t Remainder_from_block = 0;
	if(chunk_size > 0)
	{
			Sending_in_Block 		= Sending_size/buffer_size;
			Remainder_from_block 	= Sending_size%buffer_size;
	}

	// send blocks
	LCD_DC_PORT->ODR |= LCD_DC_PIN;
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	if(Sending_in_Block != 0)
	{
		for(uint32_t j = 0; j < (Sending_in_Block); j++)
		{
			_SPI_SendByteMultiByte(burst_buffer, buffer_size, 0, 9);
		}
	}

	_SPI_SendByteMultiByte(burst_buffer, Remainder_from_block, 0, 9);


	// Additional SPI CS "low" hold
	for(int x=0; x < SPI_DELAY_HOLD; x++)
		LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	LCD_CS_PORT->ODR |= LCD_CS_PIN;

}


/*
 *
 * 	Sets address (entire screen) and Sends height*width ammount of colour information to LCD
 *
 */
void ILI9341_Fill_Screen(uint16_t colour)
{
	ILI9341_Set_Address(0,0,LCD_WIDTH,LCD_HEIGHT);
	_LCD_Draw_colour_Burst(0, 0, colour, LCD_WIDTH*LCD_HEIGHT, AREA_CHUNK);
}

/*
 *
 * 	DRAW PIXEL AT XY POSITION WITH SELECTED COLOUR
 *
 * 	Location is dependant on screen orientation. x0 and y0 locations change with orientations.
 * 	Using pixels to draw big simple structures is not recommended as it is really slow
 * 	Try using either rectangles or lines if possible
 *
 */
void ILI9341_Draw_Pixel(uint16_t x,uint16_t y,uint16_t colour)
{
	if((x >= LCD_WIDTH) || (y >= LCD_HEIGHT)) return;	//OUT OF BOUNDS!

	//ADDRESS
	LCD_DC_PORT->ODR &= ~(LCD_DC_PIN);
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	_SPI_SendByte(0x2A, 0, 0);

	// Additional SPI CS "low" hold
	for(int s=0; s < SPI_DELAY_HOLD; s++)
		LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	LCD_DC_PORT->ODR |= LCD_DC_PIN;
	LCD_CS_PORT->ODR |= LCD_CS_PIN;

	//XDATA
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);
	unsigned char Temp_Buffer[4] =
	{
			x >> 8,
			x,
			(x + 1) >> 8,
			(x + 1)
	};

	_SPI_SendByteMultiByte(Temp_Buffer, 4, 0, 9);
	//HAL_SPI_Transmit(HSPI_INSTANCE, Temp_Buffer, 4, 1 );

	// Additional SPI CS "low" hold
	for(int s=0; s < SPI_DELAY_HOLD; s++)
		LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	LCD_CS_PORT->ODR |= LCD_CS_PIN;

	//ADDRESS
	LCD_DC_PORT->ODR &= ~(LCD_DC_PIN);
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	_SPI_SendByte(0x2B, 0, 0);

	// Additional SPI CS "low" hold
	for(int s=0; s < SPI_DELAY_HOLD; s++)
		LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	LCD_DC_PORT->ODR |= LCD_DC_PIN;
	LCD_CS_PORT->ODR |= LCD_CS_PIN;

	//YDATA
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);
	unsigned char Temp_Buffer1[4] =
	{
			y >> 8,
			y,
			(y + 1) >> 8,
			(y + 1)
	};

	//HAL_SPI_Transmit(HSPI_INSTANCE, Temp_Buffer1, 4, 1 );
	_SPI_SendByteMultiByte(Temp_Buffer1, 4, 0, 9);

	// Additional SPI CS "low" hold
	for(int s=0; s < SPI_DELAY_HOLD; s++)
		LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	LCD_CS_PORT->ODR |= LCD_CS_PIN;

	//ADDRESS
	LCD_DC_PORT->ODR &= ~(LCD_DC_PIN);
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	_SPI_SendByte(0x2C, 0, 0);

	// Additional SPI CS "low" hold
	for(int s=0; s < SPI_DELAY_HOLD; s++)
		LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	LCD_DC_PORT->ODR |= LCD_DC_PIN;
	LCD_CS_PORT->ODR |= LCD_CS_PIN;
	
	//COLOUR
	LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);
	unsigned char Temp_Buffer2[2] = {colour>>8, colour};

	//HAL_SPI_Transmit(HSPI_INSTANCE, Temp_Buffer2, 2, 1 );
	_SPI_SendByteMultiByte(Temp_Buffer2, 4, 0, 9);

	// Additional SPI CS "low" hold
	for(int s=0; s < SPI_DELAY_HOLD; s++)
		LCD_CS_PORT->ODR &= ~(LCD_CS_PIN);

	LCD_CS_PORT->ODR |= LCD_CS_PIN;

	
}

/*
 *
 *
 *
 */

void ILI9341_Draw_Rectangle(uint16_t xpos, uint16_t ypos, uint16_t width, uint16_t height, uint16_t colour, CHUNK_Type chunk_type)
{
	if((xpos >=LCD_WIDTH) || (ypos >=LCD_HEIGHT)) return;
	if((xpos+width-1)>=LCD_WIDTH)
		{
			width=LCD_WIDTH-xpos;
		}
	if((ypos+height-1)>=LCD_HEIGHT)
		{
			height=LCD_HEIGHT-ypos;
		}
	ILI9341_Set_Address(xpos,
						ypos,
						(xpos + width) - 1,
						(ypos + height) - 1);

	// if odd numbered rect area is requested, we round down to nearest even number
	// to keep _LCD_Draw_colour_Burst() happy.

	// Note, truncated pixel will be needed at function end.

	uint16_t size = height*width;
	uint8_t truncated = 0;

	if((size & 1) && (size > 1))		// don't round down to zero!
	{
		truncated = 1;
	 	size = ((size >> 1) * 2);
	}

	_LCD_Draw_colour_Burst(	xpos,
								ypos,
								colour,
								size,
								chunk_type);

	// add the truncated pixel now
	if(truncated)
	{
		ILI9341_Draw_Pixel(	(xpos + width) - 1,
							(ypos + height) - 1,
							colour);
	}
}

/*
 *
 *	Draw horizontal line
 *
 */

void ILI9341_Draw_Horizontal_Line(uint16_t xpos, uint16_t ypos, uint16_t width, uint16_t colour)
{
	if((xpos >=LCD_WIDTH) || (ypos >=LCD_HEIGHT)) return;
	if(((xpos + width) - 1 ) >= LCD_WIDTH)
		{
			width= LCD_WIDTH - xpos;
		}
	ILI9341_Set_Address(	xpos,
							ypos,
							(xpos + width) - 1,
							ypos);

	_LCD_Draw_colour_Burst(xpos, ypos, colour, width, LINE_CHUNK);
}

/*
 *
 *  Draw vertical line
 *
 */
void ILI9341_Draw_Vertical_Line(uint16_t xpos, uint16_t ypos, uint16_t height, uint16_t colour)
{
	if((xpos >= LCD_WIDTH) || (ypos >= LCD_HEIGHT)) return;
	if(((ypos + height) - 1) >= LCD_HEIGHT)
		{
			height= LCD_HEIGHT - ypos;
		}
	ILI9341_Set_Address(xpos, ypos, xpos, (ypos + height) - 1);
	_LCD_Draw_colour_Burst(xpos, ypos, colour, height, LINE_CHUNK);
}

